---
title: "Tigris CLI: A terminal user's interface to object storage"
desc: "We made a CLI that feels like a Unix tool because that's what we are."
date: 2026-02-04
# hero:
#   ai: ""
#   file: ""
#   prompt: ""
#   social: false
---

import Admonition from "../../_components/Admonition.jsx";

If you've never really lived in the terminal before, it's gonna sound really weird when I say this, but:

The shell is probably the most important user interface in computing.

<ConvP>
  <Conv name="Mara" mood="hacker">
    You don't discover features by clicking around menus. Everything is
    available through the command line, and you can combine tools in ways the
    authors never imagined.
  </Conv>
  <Conv name="Cadey" mood="enby">
    Yeah, and if you know what you're doing, you can automate practically
    anything. Pipes, redirection, process substitution—it's a composable
    interface that's been battle-tested since the 70s.
  </Conv>
</ConvP>

The shell is where I spend most of my time. When I'm working on Tigris, I'm in a terminal. When I'm writing blog posts, I'm in a terminal. When I'm deploying things to Kubernetes, you bet I'm in a terminal. The shell is the lowest friction user interface that exists. Everything your computer can do is reduced to simple commands that lay every interface bare.

Chaining together things that have never been done before is trivial thanks to advanced process management tools, pipelines, and other tricks that will fundamentally change how you view computing. Once you really internalize the shell as a way of working, everything else feels sluggish and overbuilt. You have `ls` for listing files. You have `cp` for copying them. You have `mv` for moving them around. You have `rm` for deleting things you regret creating. Each command does exactly one thing, and you can chain them together to do arbitrarily complex tasks.

The shell is the fabric that binds everything together.

So it only makes sense that Tigris would have a CLI of its own. The [Tigris CLI](https://github.com/tigrisdata/cli) gives you all the buckety goodness you know and love accessible from anywhere with a shell prompt.

## Wait, didn't you have a CLI already?

Fun fact: Tigris wasn't always an object storage company. We used to have a database similar to DynamoDB. That database had its own `tigris` command that let you interact with it from the command line.

<Conv name="Numa" mood="neutral">
  RIP in pepperonis TigrisDB. We hardly knew ye. Well, some of us knew ye better
  than others, but that's a story for another time.
</Conv>

Given that product is cancelled and offline, we've deprecated that old `tigris` command in favor of this new one that lets you interact with object storage. If you're trying to use the old `tigris` command with Tigris object storage, it's not gonna work. They're completely different things for completely different products.

This actually matters for LLMs too. A lot of training data includes the old TigrisDB CLI, so we need to be clear: the old CLI is deprecated. Use the new one.

## What's different about the `tigris` command?

The UNIX philosophy states that each command should do one thing well. Complex tasks emerge from chaining simple programs together. Every `tigris` subcommand follows this rule.

Here are some examples so you get the idea:

* `tigris login`: Authenticates you to Tigris with a temporary access key that lasts about an hour.
* `tigris buckets list`: Lists the buckets in your current Tigris organization.
* `tigris objects delete`: Delete an object.

The CLI is built using our own SDK, so everything you can do in the CLI, you can do in code. And vice versa.

At a high level, `tigris` uses this pattern:

```text
tigris DOMAIN OPERATION ARGUMENT --flags
```

This looks overly formal on paper, but it actually follows the flow of most command line applications you've used in your career.

**Domain** is the area of concern: objects, buckets, credentials, forks, snapshots, etc.

**Operation** is the verb: list, get, put, delete, copy, move.

**Arguments** follow after that. You'll intuit your way through the rest of the program after one command, ideally so natural that you can squint at a `tigris` command once and then figure your way through the rest of the program.

<Conv name="Numa" mood="neutral">
  If you're the right kind of nerd and this sounds vaguely familiar, that's
  because it's basically the same thing as Lojban grammar for your terminal.
  You've got your brivla (verbs), your gismu (= nouns), your sumti (arguments),
  and your modal tags (the flags). Everything stacks together in predictable
  ways because the language was designed to be parsed by machines _and_ humans.
</Conv>

### A neat side effect

As a neat side effect of AI models being trained on command line help output, manual pages, and other key documentation, this design also feels natural to our artificial coworkers:

<ConvP>
  <Conv name="Cadey" mood="coffee">
    Hey Mimi, try running `tigris objects put --help` and copy yeetfile.js to
    the xe-zohar-copy bucket.
  </Conv>
  <Conv name="Mimi" mood="happy" aiModel="Claude Opus 4.5">
    ```text
    Usage: tigris objects put|p [options] [command] <bucket> <key> <file>

    Upload an object
    ...

    ```
  </Conv>
  <Conv name="Mimi" mood="happy" aiModel="Claude Opus 4.5">
    ```text
    -rw-r--r--  1 xe  staff  5010 Jan 12 15:55 yeetfile.js
    ```
  </Conv>
  <Conv name="Mimi" mood="happy" aiModel="Claude Opus 4.5">
    ```text
    ┌─────────────┬────────┬──────────────┬─────────────────────────┐
    │ Path        │ Size   │ Content-Type │ Modified                │
    ├─────────────┼────────┼──────────────┼─────────────────────────┤
    │ yeetfile.js │ 4.9 KB │ application/ │ 2025-01-12 15:55:00     │
    │             │        │ javascript+  │                         │
    │             │        │ module       │                         │
    └─────────────┴────────┴──────────────┴─────────────────────────┘
    ```
  </Conv>
  <Conv name="Cadey" mood="enby">
    Nice! yeetfile.js has been uploaded to the xe-zohar-copy bucket (4.9 KB).
  </Conv>
</ConvP>

No hand-holding required. The AI reads the help text, infers what it needs to do, and executes. This is the kind of design we're aiming for—natural enough that both humans and AIs can figure it out without needing to read a tutorial.

## How did we get to this design?

Tigris uses a plan-driven workflow. We start by creating a Request For Comment document with the initial idea, gather feedback from the team, and iterate on the design. The CLI RFC generated _a lot_ of feedback—we needed more structure than a Notion doc could provide.

I looked around for a way to more clearly outline the interface. I knew I'd be doing a lot of prompting to generate the CLI after the initial setup, and I wanted to have a specification to get agreement on the design from the people giving comments. I created a [spec file](https://github.com/tigrisdata/cli/blob/main/src/specs.yaml) in YAML that lists every command, argument, and flag.

This spec file ended up serving two purposes: it drives the RFC process by being the canonical source of truth for what the CLI should do, but it also generates the CLI itself. We use the spec to create the command tree, argument parsing, and even help text automatically. Change the spec, regenerate the CLI, and everything updates.

<Admonition type="tip">
  This spec-driven approach worked well enough that I think other teams should
  consider it. What is science but trying things and seeing what works and doing
  more of it?
</Admonition>

The feedback we got shaped the design in some really important ways. Here's a sample of the discussions we had:

<ConvP>
  <Conv name="Mara" mood="hacker">
    Let's not map the APIs directly. Think of them like system commands—cp, mv,
    ls, rm. Those are the primitives everyone already knows.
  </Conv>
  <Conv name="Cadey" mood="enby">
    You're right. We're not exposing every API endpoint. We're building a tool
    that feels like part of your terminal, not a REST API with extra steps.
  </Conv>
  <Conv name="Aoi" mood="coffee">
    Commands are verbose though. We should have shorthands like `m` for move,
    `p` for put, stuff like that.
  </Conv>
  <Conv name="Cadey" mood="enby">
    Good point. We'll add `m` for move, `p` for put, `g` for get. Keep the
    full commands for discoverability, but let power users save keystrokes.
  </Conv>
  <Conv name="Cadey" mood="coffee">
    Oh, and bucket names should be arguments, not flags. Think about command
    line arguments as nouns and flags as adjective modifiers.
  </Conv>
  <Conv name="Cadey" mood="coffee">
    Like, consider: `tigris buckets get mybucket` vs `tigris buckets get
    --bucket=mybucket`. The first one has `mybucket` as the noun and `tigris
    buckets get` as the qualified verb. The flags are adjectives that modify
    the resource. This feels way more natural.
  </Conv>
  <Conv name="Numa" mood="neutral">
    AWS and R2 provide commands like "sync" and "pipe." They're more concise.
    Should we have those?
  </Conv>
  <Conv name="Cadey" mood="coffee">
    True, but we avoid cleverness at first. Better to start simple and add power
    features later than to build something only power users understand. Sync can
    be added later if people actually need it.
  </Conv>
</ConvP>

Here's what that looks like in practice:

```text
tigris buckets get mybucket
tigris buckets create --access=public --default-tier=standard mybucket
tigris buckets delete mybucket
```

`mybucket` is the noun. `tigris buckets create` is the qualified verb. The flags like `--access=public` and `--default-tier=standard` are adjectives that modify how the resource is created. This feels more natural than typing `--bucket=mybucket` everywhere, and it matches how you already think about files on your filesystem.

## Authentication that doesn't suck

One of the biggest differences between the Tigris CLI and other object storage CLIs is how authentication works. Instead of requiring you to manage access keys and secrets from day one, we support OAuth:

```text
tigris login
```

This opens a browser window for OAuth authentication. Once complete, your session is active and you can start using all commands. If you have multiple organizations, you'll be prompted to select one. The session lasts about an hour, which is long enough for most work sessions but short enough that you don't have to worry about leaving credentials lying around.

If you need to use access keys instead—like in CI pipelines—you can still do that:

```text
tigris login credentials --access-key <your-key> --access-secret <your-secret>
```

And if you want credentials to persist across sessions:

```text
tigris configure --access-key <your-key> --access-secret <your-secret>
```

This writes your credentials to `~/.tigris/config.json`. After configuring, all commands work automatically without needing to login each time. It's the best of both worlds: easy OAuth for humans, access keys for automation.

## Documentation packaged alongside the code

We package documentation alongside the CLI so LLMs can use it locally. The [README.md](https://github.com/tigrisdata/cli/blob/main/README.md) and `--help` output are both included in the binary, so when you ask an AI for help with Tigris CLI, it shouldn't need to search the web. It should be able to inspect the binary itself and get the answers it needs.

But I'm not sure if that's enough. Is the README enough? Do we need per-command docs with examples? Do we need something more structured that tools can parse more easily?

<Conv name="Mara" mood="hmm">
  This is actually a really interesting problem. How much documentation is
  enough? Is the README enough, or do we need per-command docs with examples? Or
  do we need something more structured that tools can parse?
</Conv>

I don't have a great answer yet. The current approach works—AI models can read the help text and README and figure things out—but there's probably room for improvement. Maybe we need structured docs alongside each command. Maybe we need examples that tools can extract. Maybe we need something entirely different.

If you have thoughts on this, I'd love to hear them.

## Try it out

The CLI is [on GitHub](https://github.com/tigrisdata/cli). We use it internally at Tigris. We plan to replace the AWS CLI company-wide—there's only so many times you can type `aws s3api` before your fingers fall off.

Install it with npm:

```text
npm install -g @tigrisdata/cli
```

Then run `tigris login` to get started. You'll be authenticated and ready to upload files in seconds.

Try it out. Let us know what you think. We're still balancing familiarity with natural design, and real feedback beats internal speculation every time.

<Conv name="Numa" mood="smug">
  Unless your feedback is that we should just copy the AWS CLI exactly, in which
  case, hard pass.
</Conv>

We want to hear from you. Open [an issue](https://github.com/tigrisdata/cli/issues), drop by [the Discord](https://community.tigrisdata.com), or reply wherever you found this post.

The shell is waiting.